/**Thrown when either too much or not enough arguments were passed. Prints what was expected and what was actually passed.*/
class BadArgumentsAmountError extends Error {
    constructor(expectedArgsNum, passedArgs, details) {
        const requiresExactNumOfArgs = !Array.isArray(expectedArgsNum);
        const argsWithValues = BadArgumentsAmountError.getArgsWithValues(passedArgs);
        const argNamesValues = BadArgumentsAmountError.getArgNamesValues(argsWithValues);
        let message;
        if (requiresExactNumOfArgs) {
            message = `Didn't receive exactly ${expectedArgsNum} arg. `;
        }
        else {
            message = `Didn't receive between ${expectedArgsNum[0]} to ${expectedArgsNum[1]} args. `;
        }
        message += `Instead, out of ${Object.keys(passedArgs).length} received (${Object.keys(passedArgs)}), ${Object.keys(argsWithValues).length} had value: "${argNamesValues}". ${details ? 'Details: ' + details : ''}`;
        super(message);
    }
    static getArgNamesValues(argsWithValues) {
        return Object.entries(argsWithValues)
            // @ts-ignore
            .flatMap(([argname, argval]) => `${argname}: ${argval}`)
            .join('", "');
    }
    static getArgsWithValues(passedArgs) {
        const argsWithValues = {};
        for (let [argname, argval] of Object.entries(passedArgs)) {
            if (argval !== undefined)
                argsWithValues[argname] = argval;
        }
        return argsWithValues;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZXB0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4Y2VwdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNEhBQTRIO0FBQzVILE1BQU0sdUJBQXdCLFNBQVEsS0FBSztJQUt2QyxZQUFZLGVBQTRDLEVBQUUsVUFBa0IsRUFBRSxPQUFnQjtRQUMxRixNQUFNLHNCQUFzQixHQUFZLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUN4RSxNQUFNLGNBQWMsR0FBRyx1QkFBdUIsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM3RSxNQUFNLGNBQWMsR0FBVyx1QkFBdUIsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN6RixJQUFJLE9BQU8sQ0FBQztRQUNaLElBQUssc0JBQXNCLEVBQUc7WUFDMUIsT0FBTyxHQUFHLDBCQUEwQixlQUFlLFFBQVEsQ0FBQTtTQUM5RDthQUFNO1lBQ0gsT0FBTyxHQUFHLDBCQUEwQixlQUFlLENBQUMsQ0FBQyxDQUFDLE9BQU8sZUFBZSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUE7U0FDM0Y7UUFDRCxPQUFPLElBQUksbUJBQW1CLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxjQUFjLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLGdCQUFnQixjQUFjLE1BQU0sT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNwTixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxjQUFzQjtRQUMzQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO1lBQ2pDLGFBQWE7YUFDSCxPQUFPLENBQUMsQ0FBQyxDQUFFLE9BQU8sRUFBRSxNQUFNLENBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxPQUFPLEtBQUssTUFBTSxFQUFFLENBQUM7YUFDekQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxNQUFNLENBQUMsaUJBQWlCLENBQUMsVUFBa0I7UUFDdkMsTUFBTSxjQUFjLEdBQVcsRUFBRSxDQUFDO1FBQ2xDLEtBQU0sSUFBSSxDQUFFLE9BQU8sRUFBRSxNQUFNLENBQUUsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFHO1lBQzFELElBQUssTUFBTSxLQUFLLFNBQVM7Z0JBQ3JCLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUM7U0FDeEM7UUFDRCxPQUFPLGNBQWMsQ0FBQztJQUMxQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyIvKipUaHJvd24gd2hlbiBlaXRoZXIgdG9vIG11Y2ggb3Igbm90IGVub3VnaCBhcmd1bWVudHMgd2VyZSBwYXNzZWQuIFByaW50cyB3aGF0IHdhcyBleHBlY3RlZCBhbmQgd2hhdCB3YXMgYWN0dWFsbHkgcGFzc2VkLiovXG5jbGFzcyBCYWRBcmd1bWVudHNBbW91bnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipAcGFyYW0gZXhwZWN0ZWRBcmdzTnVtIC0gQmVpbmcgYSBudW1iZXIgYW5kIG5vdCBhcnJheSwgaXQgaW1wbGllcyBmdW5jdGlvbiByZXF1aXJlcyBhbiBleGFjdCBudW1iZXIgb2YgYXJncyovXG4gICAgY29uc3RydWN0b3IoZXhwZWN0ZWRBcmdzTnVtOiBudW1iZXIsIHBhc3NlZEFyZ3M6IG9iamVjdCwgZGV0YWlscz86IHN0cmluZylcbiAgICAvKipAcGFyYW0gZXhwZWN0ZWRBcmdzTnVtIC0gQmVpbmcgYSAyLXR1cGxlIGFuZCBub3QgYSBudW1iZXIsIGltcGxpZXMgZnVuY3Rpb24gcmVxdWlyZXMgYmV0d2VlbiB0aGlzIGFuZCB0aGF0IG51bWJlciBvZiBhcmdzKi9cbiAgICBjb25zdHJ1Y3RvcihleHBlY3RlZEFyZ3NOdW06IFsgbnVtYmVyLCBudW1iZXIgXSwgcGFzc2VkQXJnczogb2JqZWN0LCBkZXRhaWxzPzogc3RyaW5nKVxuICAgIGNvbnN0cnVjdG9yKGV4cGVjdGVkQXJnc051bTogbnVtYmVyIHwgWyBudW1iZXIsIG51bWJlciBdLCBwYXNzZWRBcmdzOiBvYmplY3QsIGRldGFpbHM/OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcmVxdWlyZXNFeGFjdE51bU9mQXJnczogYm9vbGVhbiA9ICFBcnJheS5pc0FycmF5KGV4cGVjdGVkQXJnc051bSk7XG4gICAgICAgIGNvbnN0IGFyZ3NXaXRoVmFsdWVzID0gQmFkQXJndW1lbnRzQW1vdW50RXJyb3IuZ2V0QXJnc1dpdGhWYWx1ZXMocGFzc2VkQXJncyk7XG4gICAgICAgIGNvbnN0IGFyZ05hbWVzVmFsdWVzOiBzdHJpbmcgPSBCYWRBcmd1bWVudHNBbW91bnRFcnJvci5nZXRBcmdOYW1lc1ZhbHVlcyhhcmdzV2l0aFZhbHVlcyk7XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBpZiAoIHJlcXVpcmVzRXhhY3ROdW1PZkFyZ3MgKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYERpZG4ndCByZWNlaXZlIGV4YWN0bHkgJHtleHBlY3RlZEFyZ3NOdW19IGFyZy4gYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBEaWRuJ3QgcmVjZWl2ZSBiZXR3ZWVuICR7ZXhwZWN0ZWRBcmdzTnVtWzBdfSB0byAke2V4cGVjdGVkQXJnc051bVsxXX0gYXJncy4gYFxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gYEluc3RlYWQsIG91dCBvZiAke09iamVjdC5rZXlzKHBhc3NlZEFyZ3MpLmxlbmd0aH0gcmVjZWl2ZWQgKCR7T2JqZWN0LmtleXMocGFzc2VkQXJncyl9KSwgJHtPYmplY3Qua2V5cyhhcmdzV2l0aFZhbHVlcykubGVuZ3RofSBoYWQgdmFsdWU6IFwiJHthcmdOYW1lc1ZhbHVlc31cIi4gJHtkZXRhaWxzID8gJ0RldGFpbHM6ICcgKyBkZXRhaWxzIDogJyd9YDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxuICAgIFxuICAgIHN0YXRpYyBnZXRBcmdOYW1lc1ZhbHVlcyhhcmdzV2l0aFZhbHVlczogb2JqZWN0KTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGFyZ3NXaXRoVmFsdWVzKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgLmZsYXRNYXAoKFsgYXJnbmFtZSwgYXJndmFsIF0pID0+IGAke2FyZ25hbWV9OiAke2FyZ3ZhbH1gKVxuICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1wiLCBcIicpO1xuICAgIH1cbiAgICBcbiAgICBzdGF0aWMgZ2V0QXJnc1dpdGhWYWx1ZXMocGFzc2VkQXJnczogb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3NXaXRoVmFsdWVzOiBvYmplY3QgPSB7fTtcbiAgICAgICAgZm9yICggbGV0IFsgYXJnbmFtZSwgYXJndmFsIF0gb2YgT2JqZWN0LmVudHJpZXMocGFzc2VkQXJncykgKSB7XG4gICAgICAgICAgICBpZiAoIGFyZ3ZhbCAhPT0gdW5kZWZpbmVkIClcbiAgICAgICAgICAgICAgICBhcmdzV2l0aFZhbHVlc1thcmduYW1lXSA9IGFyZ3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1dpdGhWYWx1ZXM7XG4gICAgfVxufVxuXG5cblxuIl19